%includefile "/usr/local/share/swig/2.0.0/swig.swg" [
/* -----------------------------------------------------------------------------
 * swig.swg
 *
 * Common macro definitions for various SWIG directives.  This file is always 
 * included at the top of each input file.
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * User Directives 
 * ----------------------------------------------------------------------------- */

/* Deprecated SWIG directives */



















/* Code insertion directives such as %wrapper %{ ... %} */







/* Class extension */



/* %ignore directive */




/* Access control directives */









/* Generation of default constructors/destructors (old form, don't use) */





/* Disable the generation of implicit default constructor */




/* Disable the generation of implicit default destructor (dangerous) */




/* Enable the generation of copy constructor */




/* Force the old nodefault behavior, ie disable both constructor and destructor */




/* the %exception directive */








/* the %allowexception directive allows the %exception feature to
   be applied to set/get variable methods */




/* the %exceptionvar directive, as %exception but it is only applied
   to set/get variable methods. You don't need to use the
   %allowexception directive when using %exceptionvar.
*/








/* the %catches directive */



/* the %exceptionclass directive */




/* the %newobject directive */




/* the %delobject directive */




/* the %refobject/%unrefobject directives */








/* Directives for callback functions (experimental) */




/* the %nestedworkaround directive */




/* the %fastdispatch directive */




/* directors directives */




/* naturalvar directives */




/* nspace directives */




/* valuewrapper directives */





/* Contract support - Experimental and undocumented */




/* Macro for setting a dynamic cast function */






/* aggregation support */
/*
  This macro performs constant aggregation.  Basically the idea of
  constant aggregation is that you can group a collection of constants
  together.  For example, suppose you have some code like this:

       #define UP  1
       #define DOWN 2
       #define LEFT 3
       #define RIGHT 4

  Now, suppose you had a function like this:

       int move(int direction)

  In this case, you might want to restrict the direction argument to
  one of the supplied constant names. To do this, you could write some
  typemap code by hand.  Alternatively, you can use the
  %aggregate_check macro defined here to create a simple check
  function for you.  Here is an example:

    %aggregate_check(int, check_direction, UP, DOWN, LEFT, RIGHT);

  Now, using a typemap

    %typemap(check) int direction {
      if (!check_direction($1)) SWIG_exception(SWIG_ValueError,"Bad direction.");
    }

  or a contract (better)

    %contract move(int x) {
    require:
        check_direction(x);
    }

*/
   















/* -----------------------------------------------------------------------------
 * %rename predicates
 * ----------------------------------------------------------------------------- */
/* 
   Predicates to be used with %rename, for example:

   - to rename all the functions:

     %rename("%(utitle)s", %$isfunction) "";

   - to rename only the member methods:

     %rename("m_%(utitle)s", %$isfunction, %$ismember) "";

   - to rename only the global functions:

      %rename("m_%(utitle)s", %$isfunction, %$not %$ismember) "";

     or

      %rename("g_%(utitle)s", %$isfunction, %$isglobal) "";

   - to ignore the enumitems in a given class:

     %rename("$ignore", %$isenumitem, %$classname="MyClass") "";

   we use the prefix '%$' to avoid clashings with other swig
   macros/directives.

*/

 










  /* %constant definition */





























/* -----------------------------------------------------------------------------
 * Include all the warnings labels and macros 
 * ----------------------------------------------------------------------------- */

%includefile "/usr/local/share/swig/2.0.0/swigwarnings.swg" [
/*
  Include the internal swig macro codes. These macros correspond to
  the one found in Source/Include/swigwarn.h plus the 'SWIG' prefix.
  
  For example, in the include file 'swigwarn.h' you will find

    #define WARN_TYPEMAP_CHARLEAK ...

  and in the 'swigwarn.swg' interface, you will see

    %define SWIGWARN_TYPEMAP_CHARLEAK ...

  This code can be used in warning filters as follows:

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  Warnings messages used in typemaps. Message names will be the same
  as those in Lib/swigwarn.swg but with the suffix _MSG.
   
  For example, for the code SWIGWARN_TYPEMAP_CHARLEAK, once you use

    %typemapmsg(CHARLEAK,<msg>);

  you use the message in your typemap as

    %typemap(varin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) char * 

  while you suppress the warning using

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  as described above.
*/

/* -----------------------------------------------------------------------------
 * SWIG warning codes
 * ----------------------------------------------------------------------------- */

%includefile "/usr/local/share/swig/2.0.0/swigwarn.swg" [
/* Automatically generated file containing all the swig warning codes.  */
/* Do not modify this file by hand, change 'Source/Include/swigwarn.h'  */
/* and use the command 'make Lib/swigwarn.swg' instead.                 */


/* ----------------------------------------------------------------------------- 
 * This file is part of SWIG, which is licensed as a whole under version 3 
 * (or any later version) of the GNU General Public License. Some additional
 * terms also apply to certain portions of SWIG. The full details of the SWIG
 * license and copyrights can be found in the LICENSE and COPYRIGHT files
 * included with the SWIG source code as distributed by the SWIG developers
 * and at http://www.swig.org/legal.html.
 *
 * swigwarn.h
 *
 * SWIG warning message numbers
 * This file serves as the main registry of warning message numbers.  Some of these
 * numbers are used internally in the C/C++ source code of SWIG.   However, some
 * of the numbers are used in SWIG configuration files (swig.swg and others).
 *
 * The numbers are roughly organized into a few different classes by functionality.
 *
 * Even though symbolic constants are used in the SWIG source, this is
 * not always the case in SWIG interface files.  Do not change the
 * numbers in this file.
 * ----------------------------------------------------------------------------- */




/* -- Deprecated features -- */



























/* -- Preprocessor -- */







/* -- C/C++ Parser -- */



























 /* new */
 /* delete */
 /* + */
 /* - */
 /* * */
 /* / */
 /* % */
 /* ^ */
 /* & */
 /* | */
 /* ~ */
 /* ! */
 /* = */
 /* < */
 /* > */
 /* += */
 /* -= */
 /* *= */
 /* /= */
 /* %= */
 /* ^= */
 /* &= */
 /* |= */
 /* << */
 /* >> */
 /* <<= */
 /* >>= */
 /* == */
 /* != */
 /* <= */
 /* >= */
 /* && */
 /* || */
 /* ++ */
 /* -- */
 /* , */
 /* ->* */
 /* -> */
 /* () */
 /* [] */
 /* + */
 /* - */
 /* * */
 /* & */
 /* new [] */
 /* delete [] */
 /* operator *() */

/* 394-399 are reserved */

/* -- Type system and typemaps -- */






















 /* mostly used in directorout typemaps */






/* -- Fragments -- */


/* -- General code generation -- */





















/* -- Reserved (600-799) -- */

/* -- Language module specific warnings (800 - 999) -- */




















/* please leave 810-829 free for Java */































/* please leave 850-869 free for Modula 3 */





/* please leave 870-889 free for PHP */


/* Feel free to claim any number in this space that's not currently being used. Just make sure you
   add an entry here */


]

/* -----------------------------------------------------------------------------
 * Auxiliary macros
 * ----------------------------------------------------------------------------- */

/* Macro to define warning messages */



/* -----------------------------------------------------------------------------
 *  Typemap related warning messages
 * ----------------------------------------------------------------------------- */






/* -----------------------------------------------------------------------------
 * Operator related warning messages 
 * ----------------------------------------------------------------------------- */



















































/* -----------------------------------------------------------------------------
 * Macros for keyword and built-in names 
 * ----------------------------------------------------------------------------- */





/* -----------------------------------------------------------------------------
 * Warning filter feature
 * ----------------------------------------------------------------------------- */







]

/* -----------------------------------------------------------------------------
 * Default handling of certain overloaded operators 
 * ----------------------------------------------------------------------------- */































/* -----------------------------------------------------------------------------
 * Default char * and C array typemaps
 * ----------------------------------------------------------------------------- */

/* Set up the typemap for handling new return strings */




%typemap(newfree) char * "free($1);";


/* Default typemap for handling char * members */





































%typemap(memberin) char * {
  if ($1) free((char *)$1);
  if ($input) {
     $1 = ($1_type) malloc(strlen((const char *)$input)+1);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(memberin,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
     $1 = ($1_type) malloc(strlen((const char *)$input)+1);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin) char * {
  if ($1) free((char *)$1);
  if ($input) {
     $1 = ($1_type) malloc(strlen((const char *)$input)+1);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin,warning=        "451:Setting a const char * variable may leak memory." ) const char * {
  if ($input) {
     $1 = ($1_type) malloc(strlen((const char *)$input)+1);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}



/* Character array handling */

%typemap(memberin) char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(globalin) char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(memberin) char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

%typemap(globalin) char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

/* memberin/globalin typemap for arrays. */

%typemap(memberin) SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

%typemap(globalin) SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

/* memberin/globalin typemap for double arrays. */

%typemap(memberin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}

%typemap(globalin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}

/* Typemap for variable length arguments sentinel value.  Used
   by the %varargs directive. */

%typemap(in,numinputs=0) SWIGTYPE *VARARGS_SENTINEL, SWIGTYPE VARARGS_SENTINEL "";


/* -----------------------------------------------------------------------------
 * Overloading support
 * ----------------------------------------------------------------------------- */

/*
 * Function/method overloading support.   This is done through typemaps,
 * but also involve a precedence level. 
 */

/* Macro for overload resolution */



/* Macros for precedence levels */





































































/* -----------------------------------------------------------------------------
 *  Runtime code
 * ----------------------------------------------------------------------------- */

/*  The SwigValueWrapper class  */

/*  
 * This template wrapper is used to handle C++ objects that are passed or 
 * returned by value.   This is necessary to handle objects that define
 * no default-constructor (making it difficult for SWIG to properly declare
 * local variables).
 *
 * The wrapper is used as follows.  First consider a function like this:
 *
 *      Vector cross_product(Vector a, Vector b)
 *
 * Now, if Vector is defined as a C++ class with no default constructor, 
 * code is generated as follows:
 *
 *     Vector *wrap_cross_product(Vector *inarg1, Vector *inarg2) {
 *          SwigValueWrapper<Vector>  arg1;
 *          SwigValueWrapper<Vector>  arg2;
 *          SwigValueWrapper<Vector> result;
 *
 *          arg1 = *inarg1;
 *          arg2 = *inarg2;
 *          ...            
 *          result = cross_product(arg1,arg2);
 *          ...
 *          return new Vector(result);
 *    }
 *         
 * In the wrappers, the template SwigValueWrapper simply provides a thin
 * layer around a Vector *.  However, it does this in a way that allows
 * the object to be bound after the variable declaration (which is not possible
 * with the bare object when it lacks a default constructor).  
 *
 * An observant reader will notice that the code after the variable declarations
 * is *identical* to the code used for classes that do define default constructors.
 * Thus, this neat trick allows us to fix this special case without having to
 * make massive changes to typemaps and other parts of the SWIG code generator.
 *
 * Note: this code is not included when SWIG runs in C-mode, when classes
 * define default constructors, or when pointers and references are used.
 * SWIG tries to avoid doing this except in very special circumstances.
 *
 * Note: This solution suffers from making a large number of copies
 * of the underlying object.  However, this is needed in the interest of
 * safety and in order to cover all of the possible ways in which a value
 * might be assigned.  For example:
 *
 *       arg1 = *inarg1;       // Assignment from a pointer
 *       arg1 = Vector(1,2,3); // Assignment from a value  
 *
 * The class offers a strong guarantee of exception safety.
 * With regards to the implementation, the private SwigMovePointer nested class is 
 * a simple smart pointer with move semantics, much like std::auto_ptr.
 *
 * This wrapping technique was suggested by William Fulton and is henceforth
 * known as the "Fulton Transform" :-).
 */






































/*  The swiglabels  */

%insert("runtime") "swiglabels.swg"



]

%includefile "/usr/local/share/swig/2.0.0/go/go.swg" [
/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * go.swg
 *
 * Go typemaps
 * ----------------------------------------------------------------------------- */

/* Basic types */

%typemap(go) bool,               const bool &               "bool"
%typemap(go) char,               const char &               "byte"
%typemap(go) signed char,        const signed char &        "int8"
%typemap(go) unsigned char,      const unsigned char &      "byte"
%typemap(go) short,              const short &              "int16"
%typemap(go) unsigned short,     const unsigned short &     "uint16"
%typemap(go) int,                const int &                "int"
%typemap(go) unsigned int,       const unsigned int &       "uint"

%typemap(go) long,               const long &               "int32"
%typemap(go) unsigned long,      const unsigned long &      "uint32"






%typemap(go) long long,          const long long &          "int64"
%typemap(go) unsigned long long, const unsigned long long & "uint64"
%typemap(go) float,              const float &              "float32"
%typemap(go) double,             const double &             "float64"

%typemap(in) bool,
	     char,
	     signed char,
	     unsigned char,
	     short,
	     unsigned short,
	     int,
	     unsigned int,
	     long,
	     unsigned long,
	     long long,
	     unsigned long long,
	     float,
	     double
%{ $1 = ($1_ltype)$input; %}

%typemap(in) const bool &,
	     const char &,
	     const signed char &,
	     const unsigned char &,
	     const short &,
	     const unsigned short &,
	     const int &,
	     const unsigned int &,
	     const long &,
	     const unsigned long &,
	     const long long &,
	     const unsigned long long &,
	     const float &,
	     const doubl &e
%{ $1 = ($1_ltype)&$input; %}

%typemap(out) bool,
	      char,
	      signed char,
	      unsigned char,
	      short,
	      unsigned short,
	      int,
	      unsigned int,
	      long,
	      unsigned long,
	      long long,
	      unsigned long long,
	      float,
	      double
%{ $result = $1; %}

%typemap(out) const bool &,
	      const char &,
	      const signed char &,
	      const unsigned char &,
	      const short &,
	      const unsigned short &,
	      const int &,
	      const unsigned int &,
	      const long &,
	      const unsigned long &,
	      const long long &,
	      const unsigned long long &,
	      const float &,
	      const doubl &e
%{ $result = ($*1_ltype)*$1; %}

%typemap(out) void ""

%typemap(directorin) bool,
		     char,
		     signed char,
		     unsigned char,
		     short,
		     unsigned short,
		     int,
		     unsigned int,
		     long,
		     unsigned long,
		     long long,
		     unsigned long long,
		     float,
		     double
%{ $input = ($1_ltype)$1_name; %}

%typemap(directorin) const bool &,
		     const char &,
		     const signed char &,
		     const unsigned char &,
		     const short &,
		     const unsigned short &,
		     const int &,
		     const unsigned int &,
		     const long &,
		     const unsigned long &,
		     const long long &,
		     const unsigned long long &,
		     const float &,
		     const double &
%{ $input = ($*1_ltype)$1_name; %}

%typemap(directorout) bool,
		      char,
		      signed char,
		      unsigned char,
		      short,
		      unsigned short,
		      int,
		      unsigned int,
		      long,
		      unsigned long,
		      long long,
		      unsigned long long,
		      float,
		      double
%{ $result = ($1_ltype)$input; %}

%typemap(directorout) const bool &,
		      const char &,
		      const signed char &,
		      const unsigned char &,
		      const short &,
		      const unsigned short &,
		      const int &,
		      const unsigned int &,
		      const long &,
		      const unsigned long &,
		      const long long &,
		      const unsigned long long &,
		      const float &,
		      const double &
%{
  $result = ($1_ltype)_swig_allocate(sizeof($*1_ltype));
  *$result = *($1_ltype)$input;
%}

/* Member pointers.  */

%typemap(go) SWIGTYPE (CLASS::*)
%{ XXX %}

%typemap(in) SWIGTYPE (CLASS::*)
%{ $1 = *($&1_ltype)$input; %}

%typemap(out) SWIGTYPE (CLASS::*)
%{
  $result = _swig_allocate(sizeof($1_ltype));
  *($&1_ltype)$result = $1;
%}

%typemap(directorin) SWIGTYPE (CLASS::*)
%{ $input = *($&1_ltype)$1_name; %}

%typemap(directorout) SWIGTYPE (CLASS::*)
%{
  $result = _swig_allocate(sizeof($1_ltype));
  *($&1_ltype)$result = $input;
%}

/* Pointers.  */

/* We can't translate pointers using a typemap, so that is handled in
   the C++ code.  */
%typemap(go) SWIGTYPE *
%{ XXX %}

%typemap(in) SWIGTYPE *
%{ $1 = *($&1_ltype)&$input; %}

%typemap(out) SWIGTYPE *
%{ *($&1_ltype)&$result = $1; %}

%typemap(directorin) SWIGTYPE *
%{ $input = ($1_ltype)$1_name; %}

%typemap(directorout) SWIGTYPE *
%{ $result = ($1_ltype)$input; %}

/* Function pointers are translated by the code in go.cxx into
   _swig_fnptr.  Member pointers are translated to _swig_memberptr.  */

%insert(go_header) %{
type _swig_fnptr *byte
type _swig_memberptr *byte
%}

/* References.  */

/* Converting a C++ reference to Go has to be handled in the C++
   code.  */
%typemap(go) SWIGTYPE &
%{XXX%}

%typemap(in) SWIGTYPE &
%{ $1 = *($&1_ltype)&$input; %}

%typemap(out) SWIGTYPE &
%{ *($&1_ltype)&$result = $1; %}

%typemap(directorin) SWIGTYPE &
%{ $input = ($1_ltype)&$1_name; %}

%typemap(directorout) SWIGTYPE &
%{ *($&1_ltype)&$result = $input; %}

/* C arrays turn into Go pointers.  If we know the length we can use a
   slice.  */

%typemap(go) SWIGTYPE []
%{XXX%}

%typemap(in) SWIGTYPE []
%{ $1 = *($&1_ltype)&$input; %}

%typemap(out) SWIGTYPE []
%{ *($&1_ltype)&$result = $1; %}

%typemap(directorin) SWIGTYPE []
%{ $input = *($1_ltype)&$1_name; %}

%typemap(directorout) SWIGTYPE []
%{ *($&1_ltype)&$result = $input; %}

/* Strings.  */

%typemap(go)
	char *, char *&, char[ANY], char[],
	signed char *, signed char *&, signed char[ANY], signed char[],
	unsigned char *, unsigned char *&, unsigned char[ANY], unsigned char[]
"string"

/* Needed to avoid confusion with the way the go module handles
   references.  */
%typemap(go) char&, unsigned char& "*byte"
%typemap(go) signed char& "*int8"

%typemap(in)
	char *, char[ANY], char[],
	signed char *, signed char[ANY], signed char[],
	unsigned char *, unsigned char[ANY], unsigned char[]

%{ $1 = ($1_ltype)$input.p; %}




%typemap(in) char *&, signed char *&, unsigned char *&

%{ $1 = ($1_ltype)$input.p; %}




%typemap(out)
	char *, char *&, char[ANY], char[],
	signed char *, signed char *&, signed char[ANY], signed char[],
	unsigned char *, unsigned char *&, unsigned char[ANY], unsigned char[]
%{ $result = _swig_makegostring((char*)$1, $1 ? strlen((char*)$1) : 0); %}

%typemap(directorin)
	char *, char *&, char[ANY], char[],
	signed char *, signed char *&, signed char[ANY], signed char[],
	unsigned char *, unsigned char *&, unsigned char[ANY], unsigned char[]
%{
  $input = _swig_makegostring((char*)$1_name, $1_name ?	strlen((char*)$1_name) : 0);
%}

%typemap(directorout)
	char *, char *&, char[ANY], char[],
	signed char *, signed char *&, signed char[ANY], signed char[],
	unsigned char *, unsigned char *&, unsigned char[ANY], unsigned char[]

%{ $result = ($1_ltype)$input.p; %}




/* Enums.  We can't do the right thing for enums in typemap(go) so we
   deliberately don't define them.  The right thing would be to
   capitalize the name.  This is instead done in go.cxx.  */

%typemap(go) enum SWIGTYPE
%{XXX%}

%typemap(in) enum SWIGTYPE
%{ $1 = ($1_ltype)$input; %}

%typemap(out) enum SWIGTYPE
%{ $result = $1; %}

%typemap(directorin) enum SWIGTYPE
%{ $input = ($1_ltype)$1_name; %}

%typemap(directorout) enum SWIGTYPE
%{ $result = ($1_ltype)$input; %}

/* Arbitrary type.  This is a type passed by value in the C/C++ code.
   We convert it to a pointer for the Go code.  Note that all basic
   types are explicitly handled above.  */

%typemap(go) SWIGTYPE
%{XXX%}

%typemap(in) SWIGTYPE ($&1_type argp)
%{
  argp = *($&1_ltype*)&$input;
  if (argp == NULL) {
    _swig_gopanic("Attempt to dereference null $1_type");
  }
  $1 = ($1_ltype)*argp;
%}

%typemap(out) SWIGTYPE



{
  $&1_ltype $1ptr = ($&1_ltype)malloc(sizeof($1_ltype));
  memmove($1ptr, &$1, sizeof($1_type));
  *($&1_ltype*)&$result = $1ptr;
}


%typemap(directorin) SWIGTYPE
%{ $input = ($&1_ltype)&$1_name; %}

%typemap(directorout) SWIGTYPE
%{ $result = *($&1_ltype)$input; %}

/* Exception handling */

%typemap(throws) char *
%{ _swig_gopanic($1); %}

%typemap(throws) SWIGTYPE, SWIGTYPE &, SWIGTYPE *, SWIGTYPE [], SWIGTYPE [ANY]
%{
  (void)$1;
  _swig_gopanic("C++ $1_type exception thrown");
%}

/* Typecheck typemaps.  The purpose of these is merely to issue a
   warning for overloaded C++ functions * that cannot be overloaded in
   Go as more than one C++ type maps to a single Go type.  */

 %typemap(typecheck, precedence=         15    )  /* Go bool */
    bool,
    const bool &
    ""

 %typemap(typecheck, precedence=        130    )  /* Go byte */
    char,
    const char &,
    unsigned char,
    const unsigned char &
    ""

 %typemap(typecheck, precedence=         25    )  /* Go int8 */
    signed char,
    const signed char &
    ""

 %typemap(typecheck, precedence=        35    )  /* Go int16 */
    short,
    const short &
    ""

 %typemap(typecheck, precedence=        35    )  /* Go uint16 */
    unsigned short,
    const unsigned short &
    ""

 %typemap(typecheck, precedence=        45    )  /* Go int */
    int,
    const int &
    ""

 %typemap(typecheck, precedence=        45    )  /* Go uint */
    unsigned int,
    const unsigned int &
    ""


 %typemap(typecheck, precedence=        45    )  /* Go int32 */
    long,
    const long &
    ""

 %typemap(typecheck, precedence=        45    )  /* Go uint32 */
    unsigned long,
    const unsigned long &
    ""


 %typemap(typecheck, precedence=        55    )  /* Go int64 */




    long long,
    const long long &
    ""

 %typemap(typecheck, precedence=        55    )  /* Go uint64 */




    unsigned long long,
    const unsigned long long &
    ""

 %typemap(typecheck, precedence=        80    )  /* Go float32 */
    float,
    const float &
    ""

 %typemap(typecheck, precedence=       90    )  /* Go float64 */
    double,
    const double &
    ""

 %typemap(typecheck, precedence=      140    )  /* Go string */
    char *,
    char *&,
    char[ANY],
    char [],
    signed char *,
    signed char *&,
    signed char[ANY],
    signed char [],
    unsigned char *,
    unsigned char *&,
    unsigned char[ANY],
    unsigned char []
    ""

 %typemap(typecheck, precedence=      0     ) 
    SWIGTYPE *,
    SWIGTYPE &,
    SWIGTYPE *const&,
    SWIGTYPE [],
    SWIGTYPE (CLASS::*)
    ""

 %typemap(typecheck, precedence=       5000    ) 
    SWIGTYPE
    ""

/* Rename keywords.  */



%namewarn("314"":""'" "break" "' is a Go keyword, renaming to 'X""break""'",rename="X%s")  "break";
%namewarn("314"":""'" "case" "' is a Go keyword, renaming to 'X""case""'",rename="X%s")  "case";
%namewarn("314"":""'" "chan" "' is a Go keyword, renaming to 'X""chan""'",rename="X%s")  "chan";
%namewarn("314"":""'" "const" "' is a Go keyword, renaming to 'X""const""'",rename="X%s")  "const";
%namewarn("314"":""'" "continue" "' is a Go keyword, renaming to 'X""continue""'",rename="X%s")  "continue";
%namewarn("314"":""'" "default" "' is a Go keyword, renaming to 'X""default""'",rename="X%s")  "default";
%namewarn("314"":""'" "defer" "' is a Go keyword, renaming to 'X""defer""'",rename="X%s")  "defer";
%namewarn("314"":""'" "else" "' is a Go keyword, renaming to 'X""else""'",rename="X%s")  "else";
%namewarn("314"":""'" "fallthrough" "' is a Go keyword, renaming to 'X""fallthrough""'",rename="X%s")  "fallthrough";
%namewarn("314"":""'" "for" "' is a Go keyword, renaming to 'X""for""'",rename="X%s")  "for";
%namewarn("314"":""'" "func" "' is a Go keyword, renaming to 'X""func""'",rename="X%s")  "func";
%namewarn("314"":""'" "go" "' is a Go keyword, renaming to 'X""go""'",rename="X%s")  "go";
%namewarn("314"":""'" "goto" "' is a Go keyword, renaming to 'X""goto""'",rename="X%s")  "goto";
%namewarn("314"":""'" "if" "' is a Go keyword, renaming to 'X""if""'",rename="X%s")  "if";
%namewarn("314"":""'" "import" "' is a Go keyword, renaming to 'X""import""'",rename="X%s")  "import";
%namewarn("314"":""'" "interface" "' is a Go keyword, renaming to 'X""interface""'",rename="X%s")  "interface";
%namewarn("314"":""'" "map" "' is a Go keyword, renaming to 'X""map""'",rename="X%s")  "map";
%namewarn("314"":""'" "package" "' is a Go keyword, renaming to 'X""package""'",rename="X%s")  "package";
%namewarn("314"":""'" "range" "' is a Go keyword, renaming to 'X""range""'",rename="X%s")  "range";
%namewarn("314"":""'" "return" "' is a Go keyword, renaming to 'X""return""'",rename="X%s")  "return";
%namewarn("314"":""'" "select" "' is a Go keyword, renaming to 'X""select""'",rename="X%s")  "select";
%namewarn("314"":""'" "struct" "' is a Go keyword, renaming to 'X""struct""'",rename="X%s")  "struct";
%namewarn("314"":""'" "switch" "' is a Go keyword, renaming to 'X""switch""'",rename="X%s")  "switch";
%namewarn("314"":""'" "type" "' is a Go keyword, renaming to 'X""type""'",rename="X%s")  "type";
%namewarn("314"":""'" "var" "' is a Go keyword, renaming to 'X""var""'",rename="X%s")  "var";



%insert(runtime) %{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

%}


/* Boilerplate for C/C++ code when using 6g/8g.  This code is compiled
   with gcc.  */
%insert(runtime) %{
typedef struct { char *p; int n; } _GoString_;

typedef struct { void* array; unsigned int len; unsigned int cap; } _GoSlice_;

#define __goswig_size_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];
#define __goswig_size_assert(t, n) __goswig_size_assert_eq(sizeof(t), n, _goswig_sizeof_##t##_is_not_##n)

__goswig_size_assert(char, 1)
__goswig_size_assert(short, 2)
__goswig_size_assert(int, 4)
typedef long long __goswig_long_long;
__goswig_size_assert(__goswig_long_long, 8)
__goswig_size_assert(float, 4)
__goswig_size_assert(double, 8)

extern
#ifdef __cplusplus
"C"
#endif
void crosscall2(void (*fn)(void *, int), void *, int);

extern
#ifdef __cplusplus
"C"
#endif
void _swig_gc_allocate(void *, int);
static void *_swig_allocate(int len) {
  struct {
    int len;
    void *ret;
  } a;
  a.len = len;
  crosscall2(_swig_gc_allocate, &a, (int) sizeof a);
  return a.ret;
}

extern
#ifdef __cplusplus
"C"
#endif
void _swig_gc_makegostring(void *, int);
static _GoString_ _swig_makegostring(const char *p, size_t l) {
  struct {
    const char *p;
    int l;
    _GoString_ ret;
  } a;
  a.p = p;
  a.l = l;
  crosscall2(_swig_gc_makegostring, &a, (int) sizeof a);
  return a.ret;
}

extern
#ifdef __cplusplus
"C"
#endif
void _swig_gc_gopanic(void *, int);
static void _swig_gopanic(const char *p) {
  struct {
    const char *p;
    int l;
  } a;
  a.p = p;
  a.l = strlen(p);
  crosscall2(_swig_gc_gopanic, &a, (int) sizeof a);
}

%}

/* Boilerplate for C code when using 6g/8g.  This code is compiled
   with 6c/8c.  */
%insert(gc_header) %{
#include "runtime.h"
#include "cgocall.h"

#pragma dynimport initcgo initcgo "libcgo.so"
#pragma dynimport libcgo_thread_start libcgo_thread_start "libcgo.so"
#pragma dynimport _cgo_malloc _cgo_malloc "libcgo.so"
#pragma dynimport _cgo_free free "libcgo.so"

#ifdef _64BIT
#define SWIG_PARM_SIZE 8
#else
#define SWIG_PARM_SIZE 4
#endif

extern void ·_swig_internal_allocate(void);
#pragma dynexport _swig_gc_allocate _swig_gc_allocate
void _swig_gc_allocate(void *a, int32 n) {
	cgocallback(·_swig_internal_allocate, a, n);
}

void ·_swig_allocateMemory(int32 len, byte *ret) {
	ret = mal(len);
	FLUSH(&ret);
}

extern void ·_swig_internal_makegostring(void);
#pragma dynexport _swig_gc_makegostring _swig_gc_makegostring
void _swig_gc_makegostring(void *a, int32 n) {
	cgocallback(·_swig_internal_makegostring, a, n);
}

void ·_swig_allocatestring(byte *p, int32 l, String ret) {
	ret.str = mal(l+1);
	mcpy(ret.str, p, l);
	ret.len = l;
	FLUSH(&ret);
}

extern void ·_swig_internal_gopanic(void);
#pragma dynexport _swig_gc_gopanic _swig_gc_gopanic
void _swig_gc_gopanic(void *a, int32 n) {
	cgocallback(·_swig_internal_gopanic, a, n);
}

%}

%insert(go_header) %{
func _swig_allocateMemory(int) *byte
func _swig_internal_allocate(len int) *byte {
	return _swig_allocateMemory(len)
}

func _swig_allocatestring(*byte, int) string
func _swig_internal_makegostring(p *byte, l int) string {
	return _swig_allocatestring(p, l)
}

func _swig_internal_gopanic(p *byte, l int) {
	panic(_swig_allocatestring(p, l))
}
%}






































%insert(runtime) %{
#define SWIG_contract_assert(expr, msg) \
  if (!(expr)) { _swig_gopanic(msg); } else
%}












]
%includefile(maininput="graphics.i") "graphics.i" [
/* File : graphics.i */
%module graphics
%includefile "/usr/local/share/swig/2.0.0/go/typemaps.i" [
/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * typemaps.i
 *
 * Pointer and reference handling typemap library
 *
 * These mappings provide support for input/output arguments and common
 * uses for C/C++ pointers and C++ references.
 * ----------------------------------------------------------------------------- */

/*
INPUT typemaps
--------------

These typemaps remap a C pointer or C++ reference to be an "INPUT" value which is
passed by value instead of reference.

The following typemaps can be applied to turn a pointer or reference into a simple
input value.  That is, instead of passing a pointer or reference to an object,
you would use a real value instead.

        bool               *INPUT, bool               &INPUT
        signed char        *INPUT, signed char        &INPUT
        unsigned char      *INPUT, unsigned char      &INPUT
        short              *INPUT, short              &INPUT
        unsigned short     *INPUT, unsigned short     &INPUT
        int                *INPUT, int                &INPUT
        unsigned int       *INPUT, unsigned int       &INPUT
        long               *INPUT, long               &INPUT
        unsigned long      *INPUT, unsigned long      &INPUT
        long long          *INPUT, long long          &INPUT
        unsigned long long *INPUT, unsigned long long &INPUT
        float              *INPUT, float              &INPUT
        double             *INPUT, double             &INPUT
         
To use these, suppose you had a C function like this :

        double fadd(double *a, double *b) {
               return *a+*b;
        }

You could wrap it with SWIG as follows :
        
        %include <typemaps.i>
        double fadd(double *INPUT, double *INPUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *INPUT { double *a, double *b };
        double fadd(double *a, double *b);

In Go you could then use it like this:
        answer := modulename.Fadd(10.0, 20.0)

There are no char *INPUT typemaps, however you can apply the signed
char * typemaps instead:
        %include <typemaps.i>
        %apply signed char *INPUT {char *input};
        void f(char *input);
*/

























/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) bool *INPUT, bool &INPUT "bool"

%typemap(in) bool *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) bool &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) bool *INPUT, bool &INPUT ""

%typemap(directorout) bool *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) bool &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) bool &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) bool *INPUT = bool;
// %typemap(typecheck) bool &INPUT = bool;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) signed char *INPUT, signed char &INPUT "int8"

%typemap(in) signed char *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) signed char &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) signed char *INPUT, signed char &INPUT ""

%typemap(directorout) signed char *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) signed char &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) signed char &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) signed char *INPUT = signed char;
// %typemap(typecheck) signed char &INPUT = signed char;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) char *INPUT, char &INPUT "byte"

%typemap(in) char *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) char &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) char *INPUT, char &INPUT ""

%typemap(directorout) char *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) char &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) char &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) char *INPUT = char;
// %typemap(typecheck) char &INPUT = char;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) unsigned char *INPUT, unsigned char &INPUT "byte"

%typemap(in) unsigned char *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned char &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned char *INPUT, unsigned char &INPUT ""

%typemap(directorout) unsigned char *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned char &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned char &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) unsigned char *INPUT = unsigned char;
// %typemap(typecheck) unsigned char &INPUT = unsigned char;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) short *INPUT, short &INPUT "int16"

%typemap(in) short *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) short &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) short *INPUT, short &INPUT ""

%typemap(directorout) short *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) short &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) short &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) short *INPUT = short;
// %typemap(typecheck) short &INPUT = short;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) unsigned short *INPUT, unsigned short &INPUT "uint16"

%typemap(in) unsigned short *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned short &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned short *INPUT, unsigned short &INPUT ""

%typemap(directorout) unsigned short *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned short &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned short &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) unsigned short *INPUT = unsigned short;
// %typemap(typecheck) unsigned short &INPUT = unsigned short;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) int *INPUT, int &INPUT "int"

%typemap(in) int *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) int &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) int *INPUT, int &INPUT ""

%typemap(directorout) int *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) int &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) int &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) int *INPUT = int;
// %typemap(typecheck) int &INPUT = int;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) unsigned int *INPUT, unsigned int &INPUT "uint"

%typemap(in) unsigned int *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned int &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned int *INPUT, unsigned int &INPUT ""

%typemap(directorout) unsigned int *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned int &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned int &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) unsigned int *INPUT = unsigned int;
// %typemap(typecheck) unsigned int &INPUT = unsigned int;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) long *INPUT, long &INPUT "int64"

%typemap(in) long *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) long &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) long *INPUT, long &INPUT ""

%typemap(directorout) long *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) long &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) long &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) long *INPUT = long;
// %typemap(typecheck) long &INPUT = long;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) unsigned long *INPUT, unsigned long &INPUT "uint64"

%typemap(in) unsigned long *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned long &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned long *INPUT, unsigned long &INPUT ""

%typemap(directorout) unsigned long *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned long &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned long &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) unsigned long *INPUT = unsigned long;
// %typemap(typecheck) unsigned long &INPUT = unsigned long;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) long long *INPUT, long long &INPUT "int64"

%typemap(in) long long *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) long long &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) long long *INPUT, long long &INPUT ""

%typemap(directorout) long long *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) long long &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) long long &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) long long *INPUT = long long;
// %typemap(typecheck) long long &INPUT = long long;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) unsigned long long *INPUT, unsigned long long &INPUT "uint64"

%typemap(in) unsigned long long *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned long long &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned long long *INPUT, unsigned long long &INPUT ""

%typemap(directorout) unsigned long long *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned long long &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned long long &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) unsigned long long *INPUT = unsigned long long;
// %typemap(typecheck) unsigned long long &INPUT = unsigned long long;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) float *INPUT, float &INPUT "float"

%typemap(in) float *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) float &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) float *INPUT, float &INPUT ""

%typemap(directorout) float *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) float &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) float &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) float *INPUT = float;
// %typemap(typecheck) float &INPUT = float;
/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,65,INPUT_TYPEMAP@*/
%typemap(go) double *INPUT, double &INPUT "float64"

%typemap(in) double *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) double &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) double *INPUT, double &INPUT ""

%typemap(directorout) double *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) double &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) double &INPUT
%{ $1 = ($input_ltype)&$input; %}

// %typemap(typecheck) double *INPUT = double;
// %typemap(typecheck) double &INPUT = double;
/*@SWIG@*/;



// OUTPUT typemaps.   These typemaps are used for parameters that
// are output only.   An array replaces the c pointer or reference parameter. 
// The output value is returned in this array passed in. 

/*
OUTPUT typemaps
---------------

The following typemaps can be applied to turn a pointer or reference
into an "output" value.  When calling a function, no input value would
be given for a parameter, but an output value would be returned.  This
works by a Go slice being passed as a parameter where a c pointer or
reference is required.  As with any Go function, the array is passed
by reference so that any modifications to the array will be picked up
in the calling function.  Note that the array passed in MUST have at
least one element, but as the c function does not require any input,
the value can be set to anything.

        bool               *OUTPUT, bool               &OUTPUT
        signed char        *OUTPUT, signed char        &OUTPUT
        unsigned char      *OUTPUT, unsigned char      &OUTPUT
        short              *OUTPUT, short              &OUTPUT
        unsigned short     *OUTPUT, unsigned short     &OUTPUT
        int                *OUTPUT, int                &OUTPUT
        unsigned int       *OUTPUT, unsigned int       &OUTPUT
        long               *OUTPUT, long               &OUTPUT
        unsigned long      *OUTPUT, unsigned long      &OUTPUT
        long long          *OUTPUT, long long          &OUTPUT
        unsigned long long *OUTPUT, unsigned long long &OUTPUT
        float              *OUTPUT, float              &OUTPUT
        double             *OUTPUT, double             &OUTPUT
         
For example, suppose you were trying to wrap the modf() function in the
C math library which splits x into integral and fractional parts (and
returns the integer part in one of its parameters):

        double modf(double x, double *ip);

You could wrap it with SWIG as follows :

        %include <typemaps.i>
        double modf(double x, double *OUTPUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *OUTPUT { double *ip };
        double modf(double x, double *ip);

The Go output of the function would be the function return value and the 
value in the single element array. In Go you would use it like this:

    ptr := []float64{0.0}
    fraction := modulename.Modf(5.0,ptr)

There are no char *OUTPUT typemaps, however you can apply the signed
char * typemaps instead:
        %include <typemaps.i>
        %apply signed char *OUTPUT {char *output};
        void f(char *output);
*/














































/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) bool *OUTPUT, bool &OUTPUT %{[]bool%}

%typemap(in) bool *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) bool &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) bool *OUTPUT, bool &OUTPUT ""

%typemap(argout) bool *OUTPUT
{
  bool* a = (bool *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) bool &OUTPUT 
{
  bool* a = (bool *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide bool *OUTPUT directorout typemap") bool *OUTPUT, bool &OUTPUT {
}

%typemap(directorin) bool &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide bool *OUTPUT directorin typemap, bool array length is unknown") bool *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) signed char *OUTPUT, signed char &OUTPUT %{[]int8%}

%typemap(in) signed char *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) signed char &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) signed char *OUTPUT, signed char &OUTPUT ""

%typemap(argout) signed char *OUTPUT
{
  signed char* a = (signed char *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) signed char &OUTPUT 
{
  signed char* a = (signed char *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide signed char *OUTPUT directorout typemap") signed char *OUTPUT, signed char &OUTPUT {
}

%typemap(directorin) signed char &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide signed char *OUTPUT directorin typemap, signed char array length is unknown") signed char *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) char *OUTPUT, char &OUTPUT %{[]byte%}

%typemap(in) char *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) char &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) char *OUTPUT, char &OUTPUT ""

%typemap(argout) char *OUTPUT
{
  char* a = (char *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) char &OUTPUT 
{
  char* a = (char *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide char *OUTPUT directorout typemap") char *OUTPUT, char &OUTPUT {
}

%typemap(directorin) char &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide char *OUTPUT directorin typemap, char array length is unknown") char *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) unsigned char *OUTPUT, unsigned char &OUTPUT %{[]byte%}

%typemap(in) unsigned char *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) unsigned char &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) unsigned char *OUTPUT, unsigned char &OUTPUT ""

%typemap(argout) unsigned char *OUTPUT
{
  unsigned char* a = (unsigned char *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) unsigned char &OUTPUT 
{
  unsigned char* a = (unsigned char *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide unsigned char *OUTPUT directorout typemap") unsigned char *OUTPUT, unsigned char &OUTPUT {
}

%typemap(directorin) unsigned char &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide unsigned char *OUTPUT directorin typemap, unsigned char array length is unknown") unsigned char *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) short *OUTPUT, short &OUTPUT %{[]int16%}

%typemap(in) short *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) short &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) short *OUTPUT, short &OUTPUT ""

%typemap(argout) short *OUTPUT
{
  short* a = (short *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) short &OUTPUT 
{
  short* a = (short *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide short *OUTPUT directorout typemap") short *OUTPUT, short &OUTPUT {
}

%typemap(directorin) short &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide short *OUTPUT directorin typemap, short array length is unknown") short *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) unsigned short *OUTPUT, unsigned short &OUTPUT %{[]uint16%}

%typemap(in) unsigned short *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) unsigned short &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) unsigned short *OUTPUT, unsigned short &OUTPUT ""

%typemap(argout) unsigned short *OUTPUT
{
  unsigned short* a = (unsigned short *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) unsigned short &OUTPUT 
{
  unsigned short* a = (unsigned short *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide unsigned short *OUTPUT directorout typemap") unsigned short *OUTPUT, unsigned short &OUTPUT {
}

%typemap(directorin) unsigned short &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide unsigned short *OUTPUT directorin typemap, unsigned short array length is unknown") unsigned short *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) int *OUTPUT, int &OUTPUT %{[]int%}

%typemap(in) int *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) int &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) int *OUTPUT, int &OUTPUT ""

%typemap(argout) int *OUTPUT
{
  int* a = (int *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) int &OUTPUT 
{
  int* a = (int *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide int *OUTPUT directorout typemap") int *OUTPUT, int &OUTPUT {
}

%typemap(directorin) int &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide int *OUTPUT directorin typemap, int array length is unknown") int *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) unsigned int *OUTPUT, unsigned int &OUTPUT %{[]uint%}

%typemap(in) unsigned int *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) unsigned int &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) unsigned int *OUTPUT, unsigned int &OUTPUT ""

%typemap(argout) unsigned int *OUTPUT
{
  unsigned int* a = (unsigned int *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) unsigned int &OUTPUT 
{
  unsigned int* a = (unsigned int *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide unsigned int *OUTPUT directorout typemap") unsigned int *OUTPUT, unsigned int &OUTPUT {
}

%typemap(directorin) unsigned int &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide unsigned int *OUTPUT directorin typemap, unsigned int array length is unknown") unsigned int *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) long *OUTPUT, long &OUTPUT %{[]int64%}

%typemap(in) long *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) long &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) long *OUTPUT, long &OUTPUT ""

%typemap(argout) long *OUTPUT
{
  long* a = (long *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) long &OUTPUT 
{
  long* a = (long *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide long *OUTPUT directorout typemap") long *OUTPUT, long &OUTPUT {
}

%typemap(directorin) long &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide long *OUTPUT directorin typemap, long array length is unknown") long *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) unsigned long *OUTPUT, unsigned long &OUTPUT %{[]uint64%}

%typemap(in) unsigned long *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) unsigned long &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) unsigned long *OUTPUT, unsigned long &OUTPUT ""

%typemap(argout) unsigned long *OUTPUT
{
  unsigned long* a = (unsigned long *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) unsigned long &OUTPUT 
{
  unsigned long* a = (unsigned long *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide unsigned long *OUTPUT directorout typemap") unsigned long *OUTPUT, unsigned long &OUTPUT {
}

%typemap(directorin) unsigned long &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide unsigned long *OUTPUT directorin typemap, unsigned long array length is unknown") unsigned long *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) long long *OUTPUT, long long &OUTPUT %{[]int64%}

%typemap(in) long long *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) long long &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) long long *OUTPUT, long long &OUTPUT ""

%typemap(argout) long long *OUTPUT
{
  long long* a = (long long *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) long long &OUTPUT 
{
  long long* a = (long long *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide long long *OUTPUT directorout typemap") long long *OUTPUT, long long &OUTPUT {
}

%typemap(directorin) long long &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide long long *OUTPUT directorin typemap, long long array length is unknown") long long *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) unsigned long long *OUTPUT, unsigned long long &OUTPUT %{[]uint64%}

%typemap(in) unsigned long long *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) unsigned long long &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) unsigned long long *OUTPUT, unsigned long long &OUTPUT ""

%typemap(argout) unsigned long long *OUTPUT
{
  unsigned long long* a = (unsigned long long *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) unsigned long long &OUTPUT 
{
  unsigned long long* a = (unsigned long long *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide unsigned long long *OUTPUT directorout typemap") unsigned long long *OUTPUT, unsigned long long &OUTPUT {
}

%typemap(directorin) unsigned long long &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide unsigned long long *OUTPUT directorin typemap, unsigned long long array length is unknown") unsigned long long *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) float *OUTPUT, float &OUTPUT %{[]float%}

%typemap(in) float *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) float &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) float *OUTPUT, float &OUTPUT ""

%typemap(argout) float *OUTPUT
{
  float* a = (float *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) float &OUTPUT 
{
  float* a = (float *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide float *OUTPUT directorout typemap") float *OUTPUT, float &OUTPUT {
}

%typemap(directorin) float &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide float *OUTPUT directorin typemap, float array length is unknown") float *OUTPUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,168,OUTPUT_TYPEMAP@*/
%typemap(go) double *OUTPUT, double &OUTPUT %{[]float64%}

%typemap(in) double *OUTPUT($*1_ltype temp)
{
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(in) double &OUTPUT($*1_ltype temp)
{
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = &temp;
}

%typemap(freearg) double *OUTPUT, double &OUTPUT ""

%typemap(argout) double *OUTPUT
{
  double* a = (double *) $input.array;
  a[0] = temp$argnum;
}

%typemap(argout) double &OUTPUT 
{
  double* a = (double *) $input->array;
  a[0] = temp$argnum;
}

%typemap(directorout,warning="Need to provide double *OUTPUT directorout typemap") double *OUTPUT, double &OUTPUT {
}

%typemap(directorin) double &OUTPUT
%{ *(($&1_ltype) $input = &$1; %}

%typemap(directorin,warning="Need to provide double *OUTPUT directorin typemap, double array length is unknown") double *OUTPUT
{
}

/*@SWIG@*/;



/*
INOUT typemaps
--------------

Mappings for a parameter that is both an input and an output parameter

The following typemaps can be applied to make a function parameter both
an input and output value.  This combines the behavior of both the
"INPUT" and "OUTPUT" typemaps described earlier.  Output values are
returned as an element in a Go slice.

        bool               *INOUT, bool               &INOUT
        signed char        *INOUT, signed char        &INOUT
        unsigned char      *INOUT, unsigned char      &INOUT
        short              *INOUT, short              &INOUT
        unsigned short     *INOUT, unsigned short     &INOUT
        int                *INOUT, int                &INOUT
        unsigned int       *INOUT, unsigned int       &INOUT
        long               *INOUT, long               &INOUT
        unsigned long      *INOUT, unsigned long      &INOUT
        long long          *INOUT, long long          &INOUT
        unsigned long long *INOUT, unsigned long long &INOUT
        float              *INOUT, float              &INOUT
        double             *INOUT, double             &INOUT
         
For example, suppose you were trying to wrap the following function :

        void neg(double *x) {
             *x = -(*x);
        }

You could wrap it with SWIG as follows :

        %include <typemaps.i>
        void neg(double *INOUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *INOUT { double *x };
        void neg(double *x);

This works similarly to C in that the mapping directly modifies the
input value - the input must be an array with a minimum of one element. 
The element in the array is the input and the output is the element in 
the array.

       x := []float64{5.0}
       Neg(x);

The implementation of the OUTPUT and INOUT typemaps is different to
other languages in that other languages will return the output value
as part of the function return value. This difference is due to Go
being a typed language.

There are no char *INOUT typemaps, however you can apply the signed
char * typemaps instead:
        %include <typemaps.i>
        %apply signed char *INOUT {char *inout};
        void f(char *inout);
*/
































/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) bool *INOUT, bool &INOUT %{[]bool%}

%typemap(in) bool *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) bool &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) bool *INOUT, bool &INOUT ""

%typemap(directorout,warning="Need to provide bool *INOUT directorout typemap") bool *INOUT, bool &INOUT {
}

%typemap(directorin) bool &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide bool *INOUT directorin typemap, bool array length is unknown") bool *INOUT, bool &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) signed char *INOUT, signed char &INOUT %{[]int8%}

%typemap(in) signed char *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) signed char &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) signed char *INOUT, signed char &INOUT ""

%typemap(directorout,warning="Need to provide signed char *INOUT directorout typemap") signed char *INOUT, signed char &INOUT {
}

%typemap(directorin) signed char &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide signed char *INOUT directorin typemap, signed char array length is unknown") signed char *INOUT, signed char &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) char *INOUT, char &INOUT %{[]byte%}

%typemap(in) char *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) char &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) char *INOUT, char &INOUT ""

%typemap(directorout,warning="Need to provide char *INOUT directorout typemap") char *INOUT, char &INOUT {
}

%typemap(directorin) char &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide char *INOUT directorin typemap, char array length is unknown") char *INOUT, char &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) unsigned char *INOUT, unsigned char &INOUT %{[]byte%}

%typemap(in) unsigned char *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) unsigned char &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) unsigned char *INOUT, unsigned char &INOUT ""

%typemap(directorout,warning="Need to provide unsigned char *INOUT directorout typemap") unsigned char *INOUT, unsigned char &INOUT {
}

%typemap(directorin) unsigned char &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide unsigned char *INOUT directorin typemap, unsigned char array length is unknown") unsigned char *INOUT, unsigned char &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) short *INOUT, short &INOUT %{[]int16%}

%typemap(in) short *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) short &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) short *INOUT, short &INOUT ""

%typemap(directorout,warning="Need to provide short *INOUT directorout typemap") short *INOUT, short &INOUT {
}

%typemap(directorin) short &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide short *INOUT directorin typemap, short array length is unknown") short *INOUT, short &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) unsigned short *INOUT, unsigned short &INOUT %{[]uint16%}

%typemap(in) unsigned short *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) unsigned short &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) unsigned short *INOUT, unsigned short &INOUT ""

%typemap(directorout,warning="Need to provide unsigned short *INOUT directorout typemap") unsigned short *INOUT, unsigned short &INOUT {
}

%typemap(directorin) unsigned short &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide unsigned short *INOUT directorin typemap, unsigned short array length is unknown") unsigned short *INOUT, unsigned short &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) int *INOUT, int &INOUT %{[]int%}

%typemap(in) int *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) int &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) int *INOUT, int &INOUT ""

%typemap(directorout,warning="Need to provide int *INOUT directorout typemap") int *INOUT, int &INOUT {
}

%typemap(directorin) int &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide int *INOUT directorin typemap, int array length is unknown") int *INOUT, int &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) unsigned int *INOUT, unsigned int &INOUT %{[]uint%}

%typemap(in) unsigned int *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) unsigned int &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) unsigned int *INOUT, unsigned int &INOUT ""

%typemap(directorout,warning="Need to provide unsigned int *INOUT directorout typemap") unsigned int *INOUT, unsigned int &INOUT {
}

%typemap(directorin) unsigned int &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide unsigned int *INOUT directorin typemap, unsigned int array length is unknown") unsigned int *INOUT, unsigned int &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) long *INOUT, long &INOUT %{[]int64%}

%typemap(in) long *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) long &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) long *INOUT, long &INOUT ""

%typemap(directorout,warning="Need to provide long *INOUT directorout typemap") long *INOUT, long &INOUT {
}

%typemap(directorin) long &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide long *INOUT directorin typemap, long array length is unknown") long *INOUT, long &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) unsigned long *INOUT, unsigned long &INOUT %{[]uint64%}

%typemap(in) unsigned long *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) unsigned long &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) unsigned long *INOUT, unsigned long &INOUT ""

%typemap(directorout,warning="Need to provide unsigned long *INOUT directorout typemap") unsigned long *INOUT, unsigned long &INOUT {
}

%typemap(directorin) unsigned long &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide unsigned long *INOUT directorin typemap, unsigned long array length is unknown") unsigned long *INOUT, unsigned long &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) long long *INOUT, long long &INOUT %{[]int64%}

%typemap(in) long long *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) long long &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) long long *INOUT, long long &INOUT ""

%typemap(directorout,warning="Need to provide long long *INOUT directorout typemap") long long *INOUT, long long &INOUT {
}

%typemap(directorin) long long &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide long long *INOUT directorin typemap, long long array length is unknown") long long *INOUT, long long &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) unsigned long long *INOUT, unsigned long long &INOUT %{[]uint64%}

%typemap(in) unsigned long long *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) unsigned long long &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) unsigned long long *INOUT, unsigned long long &INOUT ""

%typemap(directorout,warning="Need to provide unsigned long long *INOUT directorout typemap") unsigned long long *INOUT, unsigned long long &INOUT {
}

%typemap(directorin) unsigned long long &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide unsigned long long *INOUT directorin typemap, unsigned long long array length is unknown") unsigned long long *INOUT, unsigned long long &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) float *INOUT, float &INOUT %{[]float%}

%typemap(in) float *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) float &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) float *INOUT, float &INOUT ""

%typemap(directorout,warning="Need to provide float *INOUT directorout typemap") float *INOUT, float &INOUT {
}

%typemap(directorin) float &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide float *INOUT directorin typemap, float array length is unknown") float *INOUT, float &INOUT
{
}

/*@SWIG@*/;
/*@SWIG:/usr/local/share/swig/2.0.0/go/typemaps.i,292,INOUT_TYPEMAP@*/
%typemap(go) double *INOUT, double &INOUT %{[]float64%}

%typemap(in) double *INOUT {
  if ($input.len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input.array;
}

%typemap(in) double &INOUT {
  if ($input->len == 0) {
    _swig_gopanic("array must contain at least 1 element");
  }
  $1 = ($1_ltype) $input->array;
}

%typemap(freearg) double *INOUT, double &INOUT ""

%typemap(directorout,warning="Need to provide double *INOUT directorout typemap") double *INOUT, double &INOUT {
}

%typemap(directorin) double &INOUT
%{ *(($&1_ltype)&$input) = &$1; %}

%typemap(directorin,warning="Need to provide double *INOUT directorin typemap, double array length is unknown") double *INOUT, double &INOUT
{
}

/*@SWIG@*/;



]

%{
	#include <SFML/Graphics.h>
%}






















/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) bool *INPUT, bool &INPUT "bool"

%typemap(in) bool *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) bool &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) bool *INPUT, bool &INPUT ""

%typemap(directorout) bool *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) bool &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) bool &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) signed char *INPUT, signed char &INPUT "int8"

%typemap(in) signed char *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) signed char &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) signed char *INPUT, signed char &INPUT ""

%typemap(directorout) signed char *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) signed char &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) signed char &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) char *INPUT, char &INPUT "byte"

%typemap(in) char *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) char &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) char *INPUT, char &INPUT ""

%typemap(directorout) char *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) char &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) char &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) unsigned char *INPUT, unsigned char &INPUT "byte"

%typemap(in) unsigned char *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned char &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned char *INPUT, unsigned char &INPUT ""

%typemap(directorout) unsigned char *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned char &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned char &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) short *INPUT, short &INPUT "int16"

%typemap(in) short *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) short &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) short *INPUT, short &INPUT ""

%typemap(directorout) short *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) short &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) short &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) unsigned short *INPUT, unsigned short &INPUT "uint16"

%typemap(in) unsigned short *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned short &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned short *INPUT, unsigned short &INPUT ""

%typemap(directorout) unsigned short *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned short &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned short &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) int *INPUT, int &INPUT "int"

%typemap(in) int *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) int &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) int *INPUT, int &INPUT ""

%typemap(directorout) int *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) int &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) int &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) unsigned int *INPUT, unsigned int &INPUT "uint"

%typemap(in) unsigned int *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned int &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned int *INPUT, unsigned int &INPUT ""

%typemap(directorout) unsigned int *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned int &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned int &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) long *INPUT, long &INPUT "int64"

%typemap(in) long *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) long &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) long *INPUT, long &INPUT ""

%typemap(directorout) long *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) long &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) long &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) unsigned long *INPUT, unsigned long &INPUT "uint64"

%typemap(in) unsigned long *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned long &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned long *INPUT, unsigned long &INPUT ""

%typemap(directorout) unsigned long *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned long &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned long &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) long long *INPUT, long long &INPUT "int64"

%typemap(in) long long *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) long long &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) long long *INPUT, long long &INPUT ""

%typemap(directorout) long long *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) long long &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) long long &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) unsigned long long *INPUT, unsigned long long &INPUT "uint64"

%typemap(in) unsigned long long *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) unsigned long long &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) unsigned long long *INPUT, unsigned long long &INPUT ""

%typemap(directorout) unsigned long long *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) unsigned long long &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) unsigned long long &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) float *INPUT, float &INPUT "float"

%typemap(in) float *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) float &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) float *INPUT, float &INPUT ""

%typemap(directorout) float *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) float &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) float &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) double *INPUT, double &INPUT "float64"

%typemap(in) double *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) double &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) double *INPUT, double &INPUT ""

%typemap(directorout) double *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) double &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) double &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) sfBool *INPUT, sfBool &INPUT "bool"

%typemap(in) sfBool *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) sfBool &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) sfBool *INPUT, sfBool &INPUT ""

%typemap(directorout) sfBool *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) sfBool &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) sfBool &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;
/*@SWIG:graphics.i,9,INPUT_TYPEMAP@*/
%typemap(go) Derek8 *INPUT, Derek8 &INPUT "sfUint8"

%typemap(in) Derek8 *INPUT
%{ $1 = ($1_ltype)&$input; %}

%typemap(in) Derek8 &INPUT
%{ $1 = ($1_ltype)$input; %}

%typemap(freearg) Derek8 *INPUT, Derek8 &INPUT ""

%typemap(directorout) Derek8 *INPUT
%{ $result = ($1_ltype)&$input; %}

%typemap(directorout) Derek8 &INPUT
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) Derek8 &INPUT
%{ $1 = ($input_ltype)&$input; %}
/*@SWIG@*/;




//typedef int sfUint8;
//typedef bool sfBool;
//%typemap int8 SfUint8;


%constant sfFalse = 0;
%constant sfTrue = 1;

/*
// Color -----------------------------------------------------------

%rename(Color) sfColor;
typedef struct
{
    int r, g, b, a;	 // Just having these here lets swig generate getters.
} sfColor;

%extend sfColor {
	sfColor(int r, int g, int b, int a) {
		sfColor temp = sfColor_FromRGBA(r,g,b,a); 
		sfColor *d;  // Possible memory leak? LETS FIND OUT. :)
		//d = (sfColor *) malloc(sizeof(sfColor));
		d = &temp;
		return d;
	}
	~sfColor() {
		free($self);
	}
	sfColor add(sfColor other) {
		return sfColor_Add(*$self, other);
	}

	sfColor modulate(sfColor other) {
		return sfColor_Modulate(*$self, other);
	}
	
	void print() {
		printf("A color for you :)");

	}
};
*/

//generated by mangler.py
//%rename(ColorFromRGB) sfColor_FromRGB;
extern sfColor sfColor_FromRGB(sfUint8 R, sfUint8 G, sfUint8 B);

//%rename(ColorFromRGBA) sfColor_FromRGBA;
extern sfColor sfColor_FromRGBA(sfUint8 R, sfUint8 G, sfUint8 B, sfUint8 A);

//%rename(ColorAdd) sfColor_Add;
extern sfColor sfColor_Add(sfColor Color1, sfColor Color2);

//%rename(ColorModulate) sfColor_Modulate;
extern sfColor sfColor_Modulate(sfColor Color1, sfColor Color2);


// Font -----------------------------------------------------------
/*
%rename(Font) sfFont;
typedef struct {} sfFont;

%extend sfFont {
	%contract sfFont(const char* Filename, int CharSize) {
	require:		
		CharSize > 0; 
	}

	sfFont(const char* Filename, int CharSize) {
		return sfFont_CreateFromFile( Filename, CharSize, NULL );
	}

	~sfFont() {
		printf("Destroying Font");
		sfFont_Destroy($self);
	}

	void Destruct(){
		printf("Destroying Font");
		sfFont_Destroy($self);
	}

	unsigned int GetCharacterSize(){
		return sfFont_GetCharacterSize($self);
	}
};
*/


%rename(FontCreate) sfFont_Create;
extern sfFont* sfFont_Create();

%rename(FontCreateFromFile) sfFont_CreateFromFile;
extern sfFont* sfFont_CreateFromFile(const char* Filename, unsigned int CharSize, const sfUint32* Charset);

%rename(FontCreateFromMemory) sfFont_CreateFromMemory;
extern sfFont* sfFont_CreateFromMemory(const char* Data, size_t SizeInBytes, unsigned int CharSize, const sfUint32* Charset);

%rename(FontDestroy) sfFont_Destroy;
extern void sfFont_Destroy(sfFont* Font);

%rename(FontGetCharacterSize) sfFont_GetCharacterSize;
extern unsigned int sfFont_GetCharacterSize(sfFont* Font);

%rename(FontGetDefaultFont) sfFont_GetDefaultFont;
extern sfFont* sfFont_GetDefaultFont();

// Image -------------------------------------------------------------------------
/*

%rename(Image) sfImage;
typedef struct {} sfImage;

%extend sfImage {
	sfImage() {
		return sfImage_Create();		
	}
	void Destruct(){
		printf("Destroying Image\n");
		sfImage_Destroy($self);
	}
};
*/

%rename(ImageCreate) sfImage_Create;
extern sfImage* sfImage_Create();

%rename(ImageCreateFromColor) sfImage_CreateFromColor;
extern sfImage* sfImage_CreateFromColor(unsigned int Width, unsigned int Height, sfColor Color);

%rename(ImageCreateFromPixels) sfImage_CreateFromPixels;
extern sfImage* sfImage_CreateFromPixels(unsigned int Width, unsigned int Height, const sfUint8* Data);

%rename(ImageCreateFromFile) sfImage_CreateFromFile;
extern sfImage* sfImage_CreateFromFile(const char* Filename);

%rename(ImageDestroy) sfImage_Destroy;
extern void sfImage_Destroy(sfImage* Image);

%rename(ImageSaveToFile) sfImage_SaveToFile;
extern sfBool sfImage_SaveToFile(sfImage* Image, const char* Filename);

%rename(ImageCreateMaskFromColor) sfImage_CreateMaskFromColor;
extern void sfImage_CreateMaskFromColor(sfImage* Image, sfColor ColorKey, sfUint8 Alpha);

%rename(ImageCopy) sfImage_Copy;
extern void sfImage_Copy(sfImage* Image, sfImage* Source, unsigned int DestX, unsigned int DestY, sfIntRect SourceRect);

%rename(ImageCopyScreen) sfImage_CopyScreen;
extern sfBool sfImage_CopyScreen(sfImage* Image, sfRenderWindow* Window, sfIntRect SourceRect);

%rename(ImageSetPixel) sfImage_SetPixel;
extern void sfImage_SetPixel(sfImage* Image, unsigned int X, unsigned int Y, sfColor Color);

%rename(ImageGetPixel) sfImage_GetPixel;
extern sfColor sfImage_GetPixel(sfImage* Image, unsigned int X, unsigned int Y);

%rename(ImageGetPixelsPtr) sfImage_GetPixelsPtr;
extern const sfUint8* sfImage_GetPixelsPtr(sfImage* Image);

%rename(ImageBind) sfImage_Bind;
extern void sfImage_Bind(sfImage* Image);

%rename(ImageSetSmooth) sfImage_SetSmooth;
extern void sfImage_SetSmooth(sfImage* Image, sfBool Smooth);

%rename(ImageGetWidth) sfImage_GetWidth;
extern unsigned int sfImage_GetWidth(sfImage* Image);

%rename(ImageGetHeight) sfImage_GetHeight;
extern unsigned int sfImage_GetHeight(sfImage* Image);

%rename(ImageIsSmooth) sfImage_IsSmooth;
extern sfBool sfImage_IsSmooth(sfImage* Image);

// PostFX -------------------------------------------------------------------------

%rename(PostFXCreateFromFile) sfPostFX_CreateFromFile;
extern sfPostFX* sfPostFX_CreateFromFile(const char* Filename);

%rename(PostFXCreateFromMemory) sfPostFX_CreateFromMemory;
extern sfPostFX* sfPostFX_CreateFromMemory(const char* Effect);

%rename(PostFXDestroy) sfPostFX_Destroy;
extern void sfPostFX_Destroy(sfPostFX* PostFX);

%rename(PostFXSetParameter1) sfPostFX_SetParameter1;
extern void sfPostFX_SetParameter1(sfPostFX* PostFX, const char* Name, float X);

%rename(PostFXSetParameter2) sfPostFX_SetParameter2;
extern void sfPostFX_SetParameter2(sfPostFX* PostFX, const char* Name, float X, float Y);

%rename(PostFXSetParameter3) sfPostFX_SetParameter3;
extern void sfPostFX_SetParameter3(sfPostFX* PostFX, const char* Name, float X, float Y, float Z);

%rename(PostFXSetParameter4) sfPostFX_SetParameter4;
extern void sfPostFX_SetParameter4(sfPostFX* PostFX, const char* Name, float X, float Y, float Z, float W);

%rename(PostFXSetTexture) sfPostFX_SetTexture;
extern void sfPostFX_SetTexture(sfPostFX* PostFX, const char* Name, sfImage* Texture);

%rename(PostFXCanUsePostFX) sfPostFX_CanUsePostFX;
extern sfBool sfPostFX_CanUsePostFX();

%rename(FloatRectOffset) sfFloatRect_Offset;
extern void sfFloatRect_Offset(sfFloatRect* Rect, float OffsetX, float OffsetY);

%rename(IntRectOffset) sfIntRect_Offset;
extern void sfIntRect_Offset(sfIntRect* Rect, int OffsetX, int OffsetY);

%rename(FloatRectContains) sfFloatRect_Contains;
extern sfBool sfFloatRect_Contains(sfFloatRect* Rect, float X, float Y);

%rename(IntRectContains) sfIntRect_Contains;
extern sfBool sfIntRect_Contains(sfIntRect* Rect, int X, int Y);

%rename(FloatRectIntersects) sfFloatRect_Intersects;
extern sfBool sfFloatRect_Intersects(sfFloatRect* Rect1, sfFloatRect* Rect2, sfFloatRect* OverlappingRect);

%rename(IntRectIntersects) sfIntRect_Intersects;
extern sfBool sfIntRect_Intersects(sfIntRect* Rect1, sfIntRect* Rect2, sfIntRect* OverlappingRect);

%rename(RenderWindowCreate) sfRenderWindow_Create;
extern sfRenderWindow* sfRenderWindow_Create(sfVideoMode Mode, const char* Title, unsigned long Style, sfWindowSettings Params);

%rename(RenderWindowCreateFromHandle) sfRenderWindow_CreateFromHandle;
extern sfRenderWindow* sfRenderWindow_CreateFromHandle(sfWindowHandle Handle, sfWindowSettings Params);

%rename(RenderWindowDestroy) sfRenderWindow_Destroy;
extern void sfRenderWindow_Destroy(sfRenderWindow* RenderWindow);

%rename(RenderWindowClose) sfRenderWindow_Close;
extern void sfRenderWindow_Close(sfRenderWindow* RenderWindow);

%rename(RenderWindowIsOpened) sfRenderWindow_IsOpened;						   
extern sfBool sfRenderWindow_IsOpened(sfRenderWindow* RenderWindow);

%rename(RenderWindowGetWidth) sfRenderWindow_GetWidth;
extern unsigned int sfRenderWindow_GetWidth(sfRenderWindow* RenderWindow);

%rename(RenderWindowGetHeight) sfRenderWindow_GetHeight;
extern unsigned int sfRenderWindow_GetHeight(sfRenderWindow* RenderWindow);

%rename(RenderWindowGetSettings) sfRenderWindow_GetSettings;
extern sfWindowSettings sfRenderWindow_GetSettings(sfRenderWindow* RenderWindow);

%rename(RenderWindowGetEvent) sfRenderWindow_GetEvent;
extern sfBool sfRenderWindow_GetEvent(sfRenderWindow* RenderWindow, sfEvent* Event);

%rename(RenderWindowUseVerticalSync) sfRenderWindow_UseVerticalSync;
extern void sfRenderWindow_UseVerticalSync(sfRenderWindow* RenderWindow, sfBool EnabOled);

%rename(RenderWindowShowMouseCursor) sfRenderWindow_ShowMouseCursor;
extern void sfRenderWindow_ShowMouseCursor(sfRenderWindow* RenderWindow, sfBool Show);

%rename(RenderWindowSetCursorPosition) sfRenderWindow_SetCursorPosition;
extern void sfRenderWindow_SetCursorPosition(sfRenderWindow* RenderWindow, unsigned int Left, unsigned int Top);

%rename(RenderWindowSetPosition) sfRenderWindow_SetPosition;
extern void sfRenderWindow_SetPosition(sfRenderWindow* RenderWindow, int Left, int Top);

%rename(RenderWindowSetSize) sfRenderWindow_SetSize;
extern void sfRenderWindow_SetSize(sfRenderWindow* RenderWindow, unsigned int Width, unsigned int Height);

%rename(RenderWindowShow) sfRenderWindow_Show;
extern void sfRenderWindow_Show(sfRenderWindow* RenderWindow, sfBool State);

%rename(RenderWindowEnableKeyRepeat) sfRenderWindow_EnableKeyRepeat;
extern void sfRenderWindow_EnableKeyRepeat(sfRenderWindow* RenderWindow, sfBool Enabled);

%rename(RenderWindowSetIcon) sfRenderWindow_SetIcon;
extern void sfRenderWindow_SetIcon(sfRenderWindow* RenderWindow, unsigned int Width, unsigned int Height, sfUint8* Pixels);

%rename(RenderWindowSetActive) sfRenderWindow_SetActive;
extern sfBool sfRenderWindow_SetActive(sfRenderWindow* RenderWindow, sfBool Active);

%rename(RenderWindowDisplay) sfRenderWindow_Display;
extern void sfRenderWindow_Display(sfRenderWindow* RenderWindow);

%rename(RenderWindowGetInput) sfRenderWindow_GetInput;
extern sfInput* sfRenderWindow_GetInput(sfRenderWindow* RenderWindow);

%rename(RenderWindowSetFramerateLimit) sfRenderWindow_SetFramerateLimit;
extern void sfRenderWindow_SetFramerateLimit(sfRenderWindow* RenderWindow, unsigned int Limit);

%rename(RenderWindowGetFrameTime) sfRenderWindow_GetFrameTime;
extern float sfRenderWindow_GetFrameTime(sfRenderWindow* RenderWindow);

%rename(RenderWindowSetJoystickThreshold) sfRenderWindow_SetJoystickThreshold;
extern void sfRenderWindow_SetJoystickThreshold(sfRenderWindow* RenderWindow, float Threshold);

%rename(RenderWindowDrawPostFX) sfRenderWindow_DrawPostFX;
extern void sfRenderWindow_DrawPostFX(sfRenderWindow* RenderWindow, sfPostFX* PostFX);

%rename(RenderWindowDrawSprite) sfRenderWindow_DrawSprite;
extern void sfRenderWindow_DrawSprite(sfRenderWindow* RenderWindow, sfSprite* Sprite);

%rename(RenderWindowDrawShape) sfRenderWindow_DrawShape;
extern void sfRenderWindow_DrawShape(sfRenderWindow* RenderWindow, sfShape*  Shape);

%rename(RenderWindowDrawString) sfRenderWindow_DrawString;
extern void sfRenderWindow_DrawString(sfRenderWindow* RenderWindow, sfString* String);

%rename(RenderWindowCapture) sfRenderWindow_Capture;
extern sfImage* sfRenderWindow_Capture(sfRenderWindow* RenderWindow);

%rename(RenderWindowClear) sfRenderWindow_Clear;
extern void sfRenderWindow_Clear(sfRenderWindow* RenderWindow, sfColor Color);

%rename(RenderWindowSetView) sfRenderWindow_SetView;
extern void sfRenderWindow_SetView(sfRenderWindow* RenderWindow, sfView* View);

%rename(RenderWindowGetView) sfRenderWindow_GetView;
extern const sfView* sfRenderWindow_GetView(sfRenderWindow* RenderWindow);

%rename(RenderWindowGetDefaultView) sfRenderWindow_GetDefaultView;
extern sfView* sfRenderWindow_GetDefaultView(sfRenderWindow* RenderWindow);

%rename(RenderWindowConvertCoords) sfRenderWindow_ConvertCoords;
extern void sfRenderWindow_ConvertCoords(sfRenderWindow* RenderWindow, unsigned int WindowX, unsigned int WindowY, float* ViewX, float* ViewY, sfView* TargetView);

%rename(RenderWindowPreserveOpenGLStates) sfRenderWindow_PreserveOpenGLStates;
extern void sfRenderWindow_PreserveOpenGLStates(sfRenderWindow* RenderWindow, sfBool Preserve);

%rename(ShapeCreate) sfShape_Create;
extern sfShape* sfShape_Create();

%rename(ShapeCreateLine) sfShape_CreateLine;
extern sfShape* sfShape_CreateLine(float P1X, float P1Y, float P2X, float P2Y, float Thickness, sfColor Col, float Outline, sfColor OutlineCol);

%rename(ShapeCreateRectangle) sfShape_CreateRectangle;
extern sfShape* sfShape_CreateRectangle(float P1X, float P1Y, float P2X, float P2Y, sfColor Col, float Outline, sfColor OutlineCol);

%rename(ShapeCreateCircle) sfShape_CreateCircle;
extern sfShape* sfShape_CreateCircle(float X, float Y, float Radius, sfColor Col, float Outline, sfColor OutlineCol);

%rename(ShapeDestroy) sfShape_Destroy;
extern void sfShape_Destroy(sfShape* Shape);

%rename(ShapeSetX) sfShape_SetX;
extern void sfShape_SetX(sfShape* Shape, float X);

%rename(ShapeSetY) sfShape_SetY;
extern void sfShape_SetY(sfShape* Shape, float Y);

%rename(ShapeSetPosition) sfShape_SetPosition;
extern void sfShape_SetPosition(sfShape* Shape, float X, float Y);

%rename(ShapeSetScaleX) sfShape_SetScaleX;
extern void sfShape_SetScaleX(sfShape* Shape, float Scale);

%rename(ShapeSetScaleY) sfShape_SetScaleY;
extern void sfShape_SetScaleY(sfShape* Shape, float Scale);

%rename(ShapeSetScale) sfShape_SetScale;
extern void sfShape_SetScale(sfShape* Shape, float ScaleX, float ScaleY);

%rename(ShapeSetRotation) sfShape_SetRotation;
extern void sfShape_SetRotation(sfShape* Shape, float Rotation);

%rename(ShapeSetCenter) sfShape_SetCenter;
extern void sfShape_SetCenter(sfShape* Shape, float X, float Y);

%rename(ShapeSetColor) sfShape_SetColor;
extern void sfShape_SetColor(sfShape* Shape, sfColor Color);

%rename(ShapeSetBlendMode) sfShape_SetBlendMode;
extern void sfShape_SetBlendMode(sfShape* Shape, sfBlendMode Mode);

%rename(ShapeGetX) sfShape_GetX;
extern float sfShape_GetX(sfShape* Shape);

%rename(ShapeGetY) sfShape_GetY;
extern float sfShape_GetY(sfShape* Shape);

%rename(ShapeGetScaleX) sfShape_GetScaleX;
extern float sfShape_GetScaleX(sfShape* Shape);

%rename(ShapeGetScaleY) sfShape_GetScaleY;
extern float sfShape_GetScaleY(sfShape* Shape);

%rename(ShapeGetRotation) sfShape_GetRotation;
extern float sfShape_GetRotation(sfShape* Shape);

%rename(ShapeGetCenterX) sfShape_GetCenterX;
extern float sfShape_GetCenterX(sfShape* Shape);

%rename(ShapeGetCenterY) sfShape_GetCenterY;
extern float sfShape_GetCenterY(sfShape* Shape);

%rename(ShapeGetColor) sfShape_GetColor;
extern sfColor sfShape_GetColor(sfShape* Shape);

%rename(ShapeGetBlendMode) sfShape_GetBlendMode;
extern sfBlendMode sfShape_GetBlendMode(sfShape* Shape);

%rename(ShapeMove) sfShape_Move;
extern void sfShape_Move(sfShape* Shape, float OffsetX, float OffsetY);

%rename(ShapeScale) sfShape_Scale;
extern void sfShape_Scale(sfShape* Shape, float FactorX, float FactorY);

%rename(ShapeRotate) sfShape_Rotate;
extern void sfShape_Rotate(sfShape* Shape, float Angle);

%rename(ShapeTransformToLocal) sfShape_TransformToLocal;
extern void sfShape_TransformToLocal(sfShape* Shape, float PointX, float PointY, float* X, float* Y);

%rename(ShapeTransformToGlobal) sfShape_TransformToGlobal;
extern void sfShape_TransformToGlobal(sfShape* Shape, float PointX, float PointY, float* X, float* Y);

%rename(ShapeAddPoint) sfShape_AddPoint;
extern void sfShape_AddPoint(sfShape* Shape, float X, float Y, sfColor Col, sfColor OutlineCol);

%rename(ShapeEnableFill) sfShape_EnableFill;
extern void sfShape_EnableFill(sfShape* Shape, sfBool Enable);

%rename(ShapeEnableOutline) sfShape_EnableOutline;
extern void sfShape_EnableOutline(sfShape* Shape, sfBool Enable);

%rename(ShapeSetOutlineWidth) sfShape_SetOutlineWidth;
extern void sfShape_SetOutlineWidth(sfShape* Shape, float Width);

%rename(ShapeGetOutlineWidth) sfShape_GetOutlineWidth;
extern float sfShape_GetOutlineWidth(sfShape* Shape);

%rename(ShapeGetNbPoints) sfShape_GetNbPoints;
extern unsigned int sfShape_GetNbPoints(sfShape* Shape);

%rename(ShapeGetPointPosition) sfShape_GetPointPosition;
extern void sfShape_GetPointPosition(sfShape* Shape, unsigned int Index, float* X, float* Y);

%rename(ShapeGetPointColor) sfShape_GetPointColor;
extern sfColor sfShape_GetPointColor(sfShape* Shape, unsigned int Index);

%rename(ShapeGetPointOutlineColor) sfShape_GetPointOutlineColor;
extern sfColor sfShape_GetPointOutlineColor(sfShape* Shape, unsigned int Index);

%rename(ShapeSetPointPosition) sfShape_SetPointPosition;
extern void sfShape_SetPointPosition(sfShape* Shape, unsigned int Index, float X, float Y);

%rename(ShapeSetPointColor) sfShape_SetPointColor;
extern void sfShape_SetPointColor(sfShape* Shape, unsigned int Index, sfColor Color);

%rename(ShapeSetPointOutlineColor) sfShape_SetPointOutlineColor;
extern void sfShape_SetPointOutlineColor(sfShape* Shape, unsigned int Index, sfColor Color);

%rename(SpriteCreate) sfSprite_Create;
extern sfSprite* sfSprite_Create();

%rename(SpriteDestroy) sfSprite_Destroy;
extern void sfSprite_Destroy(sfSprite* Sprite);

%rename(SpriteSetX) sfSprite_SetX;
extern void sfSprite_SetX(sfSprite* Sprite, float X);

%rename(SpriteSetY) sfSprite_SetY;
extern void sfSprite_SetY(sfSprite* Sprite, float Y);

%rename(SpriteSetPosition) sfSprite_SetPosition;
extern void sfSprite_SetPosition(sfSprite* Sprite, float X, float Y);

%rename(SpriteSetScaleX) sfSprite_SetScaleX;
extern void sfSprite_SetScaleX(sfSprite* Sprite, float Scale);

%rename(SpriteSetScaleY) sfSprite_SetScaleY;
extern void sfSprite_SetScaleY(sfSprite* Sprite, float Scale);

%rename(SpriteSetScale) sfSprite_SetScale;
extern void sfSprite_SetScale(sfSprite* Sprite, float ScaleX, float ScaleY);

%rename(SpriteSetRotation) sfSprite_SetRotation;
extern void sfSprite_SetRotation(sfSprite* Sprite, float Rotation);

%rename(SpriteSetCenter) sfSprite_SetCenter;
extern void sfSprite_SetCenter(sfSprite* Sprite, float X, float Y);

%rename(SpriteSetColor) sfSprite_SetColor;
extern void sfSprite_SetColor(sfSprite* Sprite, sfColor Color);

%rename(SpriteSetBlendMode) sfSprite_SetBlendMode;
extern void sfSprite_SetBlendMode(sfSprite* Sprite, sfBlendMode Mode);

%rename(SpriteGetX) sfSprite_GetX;
extern float sfSprite_GetX(sfSprite* Sprite);

%rename(SpriteGetY) sfSprite_GetY;
extern float sfSprite_GetY(sfSprite* Sprite);

%rename(SpriteGetScaleX) sfSprite_GetScaleX;
extern float sfSprite_GetScaleX(sfSprite* Sprite);

%rename(SpriteGetScaleY) sfSprite_GetScaleY;
extern float sfSprite_GetScaleY(sfSprite* Sprite);

%rename(SpriteGetRotation) sfSprite_GetRotation;
extern float sfSprite_GetRotation(sfSprite* Sprite);

%rename(SpriteGetCenterX) sfSprite_GetCenterX;
extern float sfSprite_GetCenterX(sfSprite* Sprite);

%rename(SpriteGetCenterY) sfSprite_GetCenterY;
extern float sfSprite_GetCenterY(sfSprite* Sprite);

%rename(SpriteGetColor) sfSprite_GetColor;
extern sfColor sfSprite_GetColor(sfSprite* Sprite);

%rename(SpriteGetBlendMode) sfSprite_GetBlendMode;
extern sfBlendMode sfSprite_GetBlendMode(sfSprite* Sprite);

%rename(SpriteMove) sfSprite_Move;
extern void sfSprite_Move(sfSprite* Sprite, float OffsetX, float OffsetY);

%rename(SpriteScale) sfSprite_Scale;
extern void sfSprite_Scale(sfSprite* Sprite, float FactorX, float FactorY);

%rename(SpriteRotate) sfSprite_Rotate;
extern void sfSprite_Rotate(sfSprite* Sprite, float Angle);

%rename(SpriteTransformToLocal) sfSprite_TransformToLocal;
extern void sfSprite_TransformToLocal(sfSprite* Sprite, float PointX, float PointY, float* X, float* Y);

%rename(SpriteTransformToGlobal) sfSprite_TransformToGlobal;
extern void sfSprite_TransformToGlobal(sfSprite* Sprite, float PointX, float PointY, float* X, float* Y);

%rename(SpriteSetImage) sfSprite_SetImage;
extern void sfSprite_SetImage(sfSprite* Sprite, sfImage* Image);

%rename(SpriteSetSubRect) sfSprite_SetSubRect;
extern void sfSprite_SetSubRect(sfSprite* Sprite, sfIntRect SubRect);

%rename(SpriteResize) sfSprite_Resize;
extern void sfSprite_Resize(sfSprite* Sprite, float Width, float Height);

%rename(SpriteFlipX) sfSprite_FlipX;
extern void sfSprite_FlipX(sfSprite* Sprite, sfBool Flipped);

%rename(SpriteFlipY) sfSprite_FlipY;
extern void sfSprite_FlipY(sfSprite* Sprite, sfBool Flipped);

%rename(SpriteGetImage) sfSprite_GetImage;
extern sfImage* sfSprite_GetImage(sfSprite* Sprite);

%rename(SpriteGetSubRect) sfSprite_GetSubRect;
extern sfIntRect sfSprite_GetSubRect(sfSprite* Sprite);

%rename(SpriteGetWidth) sfSprite_GetWidth;
extern float sfSprite_GetWidth(sfSprite* Sprite);

%rename(SpriteGetHeight) sfSprite_GetHeight;
extern float sfSprite_GetHeight(sfSprite* Sprite);

%rename(SpriteGetPixel) sfSprite_GetPixel;
extern sfColor sfSprite_GetPixel(sfSprite* Sprite, unsigned int X, unsigned int Y);

%rename(StringCreate) sfString_Create;
extern sfString* sfString_Create();

%rename(StringDestroy) sfString_Destroy;
extern void sfString_Destroy(sfString* String);

%rename(StringSetX) sfString_SetX;
extern void sfString_SetX(sfString* String, float X);

%rename(StringSetY) sfString_SetY;
extern void sfString_SetY(sfString* String, float Y);

%rename(StringSetPosition) sfString_SetPosition;
extern void sfString_SetPosition(sfString* String, float Left, float Top);

%rename(StringSetScaleX) sfString_SetScaleX;
extern void sfString_SetScaleX(sfString* String, float Scale);

%rename(StringSetScaleY) sfString_SetScaleY;
extern void sfString_SetScaleY(sfString* String, float Scale);

%rename(StringSetScale) sfString_SetScale;
extern void sfString_SetScale(sfString* String, float ScaleX, float ScaleY);

%rename(StringSetRotation) sfString_SetRotation;
extern void sfString_SetRotation(sfString* String, float Rotation);

%rename(StringSetCenter) sfString_SetCenter;
extern void sfString_SetCenter(sfString* String, float X, float Y);

%rename(StringSetColor) sfString_SetColor;
extern void sfString_SetColor(sfString* String, sfColor Color);

%rename(StringSetBlendMode) sfString_SetBlendMode;
extern void sfString_SetBlendMode(sfString* String, sfBlendMode Mode);

%rename(StringGetX) sfString_GetX;
extern float sfString_GetX(sfString* String);

%rename(StringGetY) sfString_GetY;
extern float sfString_GetY(sfString* String);

%rename(StringGetScaleX) sfString_GetScaleX;
extern float sfString_GetScaleX(sfString* String);

%rename(StringGetScaleY) sfString_GetScaleY;
extern float sfString_GetScaleY(sfString* String);

%rename(StringGetRotation) sfString_GetRotation;
extern float sfString_GetRotation(sfString* String);

%rename(StringGetCenterX) sfString_GetCenterX;
extern float sfString_GetCenterX(sfString* String);

%rename(StringGetCenterY) sfString_GetCenterY;
extern float sfString_GetCenterY(sfString* String);

%rename(StringGetColor) sfString_GetColor;
extern sfColor sfString_GetColor(sfString* String);

%rename(StringGetBlendMode) sfString_GetBlendMode;
extern sfBlendMode sfString_GetBlendMode(sfString* String);

%rename(StringMove) sfString_Move;
extern void sfString_Move(sfString* String, float OffsetX, float OffsetY);

%rename(StringScale) sfString_Scale;
extern void sfString_Scale(sfString* String, float FactorX, float FactorY);

%rename(StringRotate) sfString_Rotate;
extern void sfString_Rotate(sfString* String, float Angle);

%rename(StringTransformToLocal) sfString_TransformToLocal;
extern void sfString_TransformToLocal(sfString* String, float PointX, float PointY, float* X, float* Y);

%rename(StringTransformToGlobal) sfString_TransformToGlobal;
extern void sfString_TransformToGlobal(sfString* String, float PointX, float PointY, float* X, float* Y);

%rename(StringSetText) sfString_SetText;
extern void sfString_SetText(sfString* String, const char* Text);

%rename(StringSetUnicodeText) sfString_SetUnicodeText;
extern void sfString_SetUnicodeText(sfString* String, const sfUint32* Text);

%rename(StringSetFont) sfString_SetFont;
extern void sfString_SetFont(sfString* String, sfFont* Font);

%rename(StringSetSize) sfString_SetSize;
extern void sfString_SetSize(sfString* String, float Size);

%rename(StringSetStyle) sfString_SetStyle;
extern void sfString_SetStyle(sfString* String, unsigned long Style);

%rename(StringGetUnicodeText) sfString_GetUnicodeText;
extern const sfUint32* sfString_GetUnicodeText(sfString* String);

%rename(StringGetText) sfString_GetText;
extern const char* sfString_GetText(sfString* String);

%rename(StringGetFont) sfString_GetFont;
extern sfFont* sfString_GetFont(sfString* String);

%rename(StringGetSize) sfString_GetSize;
extern float sfString_GetSize(sfString* String);

%rename(StringGetStyle) sfString_GetStyle;
extern unsigned long sfString_GetStyle(sfString* String);

%rename(StringGetCharacterPos) sfString_GetCharacterPos;
extern void sfString_GetCharacterPos(sfString* String, size_t Index, float* X, float* Y);

%rename(StringGetRect) sfString_GetRect;
extern sfFloatRect sfString_GetRect(sfString* String);

%rename(ViewCreate) sfView_Create;
extern sfView* sfView_Create();

%rename(ViewCreateFromRect) sfView_CreateFromRect;
extern sfView* sfView_CreateFromRect(sfFloatRect Rect);

%rename(ViewDestroy) sfView_Destroy;
extern void sfView_Destroy(sfView* View);

%rename(ViewSetCenter) sfView_SetCenter;
extern void sfView_SetCenter(sfView* View, float X, float Y);

%rename(ViewSetHalfSize) sfView_SetHalfSize;
extern void sfView_SetHalfSize(sfView* View, float HalfWidth, float HalfHeight);

%rename(ViewSetFromRect) sfView_SetFromRect;
extern void sfView_SetFromRect(sfView* View, sfFloatRect ViewRect);

%rename(ViewGetCenterX) sfView_GetCenterX;
extern float sfView_GetCenterX(sfView* View);

%rename(ViewGetCenterY) sfView_GetCenterY;
extern float sfView_GetCenterY(sfView* View);

%rename(ViewGetHalfSizeX) sfView_GetHalfSizeX;
extern float sfView_GetHalfSizeX(sfView* View);

%rename(ViewGetHalfSizeY) sfView_GetHalfSizeY;
extern float sfView_GetHalfSizeY(sfView* View);

%rename(ViewGetRect) sfView_GetRect;
extern sfFloatRect sfView_GetRect(sfView* View);

%rename(ViewMove) sfView_Move;
extern void sfView_Move(sfView* View, float OffsetX, float OffsetY);

%rename(ViewZoom) sfView_Zoom;
extern void sfView_Zoom(sfView* View, float Factor);


]
